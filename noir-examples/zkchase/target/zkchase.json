{"noir_version":"0.32.0+c679f01a19b02ad2ac2287c8e699b46887f7872c","hash":15807912845410565985,"abi":{"parameters":[{"name":"map0","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]},"visibility":"public"},{"name":"map1","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]},"visibility":"public"},{"name":"prev_pos_hash","type":{"kind":"field"},"visibility":"public"},{"name":"prev_pos","type":{"kind":"field"},"visibility":"private"},{"name":"move","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"23":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field/mod.nr"},"53":{"source":"// \n// \n// \n\n// This is an \nglobal COLS = 18;\nglobal ROWS = 14;\n\nfn sq(x: Field) -> Field {\n    x * x\n}\n\nfn cu(x: Field) -> Field {\n    x * x * x\n}\n\n// hashes two inputs\nfn hash(val: Field, salt: Field) -> Field {\n    // let mut slt = salt as u64;\n    // let val = val as u64;\n    let salts = [\n        0xf8bf3bd6c22ba3b1bf3ab2e3fb40818cd4217ffbaf294ca42331d4e3043a0a6,\n        0x388c9fcf30fc2841d648f46bad01dd10bee9dc184d25eabc9f617021109cec3,\n        0x2bb7f397c5941ac67befa8b232f15c8853dac263da793555441a90cec83b6454,\n        0x17f389b52f9ea7a98874a4a31ef6a7beb43fb17db0e499250bb3f0181c59fb21,\n        0x3a2090eacb897a31fb10561d560a9aeec24b7ad14d17b145f20c875a0b28c7c,\n        0xc398534f0eb580f1fe4bf64553389e67cca4714399430e09619dcbee17ba099,\n        0x7095ac9fda46afa7f181259e3635feffa7f11ee63f3ee777a5cebf4822328c4,\n        0x2046f7cf1c8f13ef2b69cbc8bc0d5d809f82568abe2b33d1cd060958b1ced683,\n    ];\n\n    let v = val * salts[0];\n    let v = v * v * v * (salt + salts[1]); // v ** 3\n    let v = sq(sq(v)) * v * (salt + salts[2]); // v ** 5\n    let v2 = sq(v);\n    let v = cu(v2) * v * (salt + salts[3]); // v ** 7\n    let v2 = sq(v);\n    let v4 = sq(v2);\n    let v = sq(v4) * v2 * v * (salt + salts[5]); // v ** 11\n    let v4 = sq(sq(v));\n    let v = cu(v4) * v * (salt + salts[6]); // v ** 13\n    let v = sq(sq(sq(sq(v)))) * v * (salt + salts[7]); // v ** 17\n    let v2 = sq(v);\n    let v = sq(sq(sq(v2))) * v2 * v * (salt + salts[7]); // v ** 19\n\n    v\n}\n\nfn expand_position(position: Field) -> (u8, u8) {\n    let pos_bytes = position.to_be_bytes(2);\n    let mut px = pos_bytes[0];\n    let mut py = pos_bytes[1];\n    (px, py)\n}\n\nfn compress_position(x: u8, y: u8) -> Field {\n    (x as u64 + y as u64 * 256 as u64) as Field\n}\n\nfn make_move(prev_pos: Field, move: u8) -> (u8, u8) {\n    let (mut px, mut py) = expand_position(prev_pos);\n\n    if move == 1 {\n        py += 1;\n    } else if move == 2 {\n        py -= 1;\n    } else if move == 3 {\n        px -= 1;\n    } else if move == 4 {\n        px += 1;\n    } else {\n        assert(false, \"Invalid move\");\n    }\n    (py, px)\n}\n\n// Get map bit at x, y\nfn map_bit(map0: U128, map1: U128, x: u8, mut y: u8) -> u8 {\n    let mut map = map0;\n    let mut bit = y * COLS + x;\n    // print(x);\n    // print(\" \");\n    // print(y);\n    // print(\" \");\n    // print(bit);\n    // print(\" \");\n\n    // print(\"bit[ \");\n    // print(bit);\n\n    // We have a map in two U128, m0 and m1\n    // determine which one to use base on the row (y)\n    if bit > 125 {\n        bit = bit - 126;\n        map = map1;\n    }\n    // Now use map.lo or map.hi if bit value to fetch is greater than 63\n    let mut map_part = map.lo as u64;\n    let mut total_bits: u8 = 63;\n    // print(\" ~ \");\n    // print(bit);\n    // print(\" \");\n    if bit > 63 {\n        map_part = map.hi as u64;\n        bit -= 64;\n        total_bits = 61;\n    }\n\n    // bits to drop, everything after the reqd bit\n    let mut drop_bits = bit;\n    // print(\" ] \");\n    let divide_drop_bits: u64 = 1 as u64 << (drop_bits as u8);\n    // divide by power of two to drop lower bits\n    let remainder_map = map_part / divide_drop_bits as u64;\n    // drop higher bits\n    let bit = remainder_map % 2;\n\n    // print(\"map: \");\n    // print(map_part);\n    // print(\" bit: \");\n    // print(bit);\n\n    bit as u8\n}\n\n// Main game circuit\n// map: public for Cairo contract to assert equivalence\n//      and that bushes are correct places in Cairo and the circuit\n// prev_pos_hash: public for Cairo contract to compare against the prev pos\n// prev_pos: private previous position (before playing move)\n// move: between 1, 2, 3, 4 for moving UP, DOWN, LEFT, RIGHT\n// salt: for hashing\n// returns: public new position hash output for Cairo contract to store in state for next iteration\nfn main(\n    map0: pub U128,\n    map1: pub U128,\n    prev_pos_hash: pub Field,\n    prev_pos: Field,\n    move: u8,\n    salt: Field //\n) -> pub Field {\n    // public for Cairo contract assert equivalence\n    // To make sure bushes are same in Cairo and the circuit\n\n    // Step 1: Output prev public hash\n    assert(hash(prev_pos, salt) == prev_pos_hash);\n\n    // Step 2: Process move\n    let (x, y) = make_move(prev_pos, move);\n\n    // Step 3: Assert move is in the bush\n    let bush = map_bit(map0, map1, x, y);\n    assert(1 == bush);\n\n    // Step 4: Output new public hash\n    let pos = compress_position(x, y);\n\n    hash(pos, salt)\n}\n\nmod test {\n    use crate::{main, map_bit, hash};\n    /*\n     000110011100110000\n     001110011100111000\n     001110000000011110\n     001100111111001111\n     011101111111100111\n     111001110011100000\n     110001100001100000\n    */\n    global MAP1 = U128::from_integer(8572555389858747807877673192308021344);\n\n    /*\n     000001100001100011\n     000001110011100111\n     111001111111101110\n     111100111111001100\n     011110000000011100\n     000111001110011100\n     000011001110011000\n    */\n    global MAP0 = U128::from_integer(2025978491129711385918832679433810840);\n\n    #[test]\n    fn test_bush() {\n        let rows = [\n            [0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0],\n            [0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0],\n            [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0],\n            [0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1],\n            [0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1],\n            [1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0],\n            [1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1],\n            [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1],\n            [1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0],\n            [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0],\n            [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0],\n            [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n            [0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0]\n        ];\n\n        for y in 0..14 {\n            // println(\"\");\n            // print(\"printing row: \");\n            // println(y);\n            let row = rows[y];\n            for i in 0..18 {\n                // let i = 17 - i;\n                // print(i);\n                // print(\" : \");\n                let bit = map_bit(MAP0, MAP1, i, y);\n                // print(bit);\n                if bit == row[i] {\n                    // print(\" == \");\n                } else {\n                    // print(\" != \");\n                }\n                // println(row[i]);\n                // assert(row[17 - i] == bit);\n            }\n        }\n    }\n\n    #[test]\n    fn test_main() {\n        let salt = 2134924215;\n\n        let prev_pos = 0x705;\n        let prev_pos_hash = hash(prev_pos, salt);\n        // print(\"post_hash: \");\n        // println(hash(0x704, salt));\n        let move = 2;\n        let result = main(MAP1, MAP0, prev_pos_hash, prev_pos, move, salt);\n        assert(result == hash(0x704, salt));\n    }\n}\n","path":"/Users/shramee/www/starknet/noir-r1cs/noir-examples/zkchase/src/main.nr"}},"names":["main"]}