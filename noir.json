{"noir_version":"0.31.0+540bef3597bd3e5775c83ec2ee3c0d4463084b4c","hash":10390112263486795119,"abi":{"parameters":[{"name":"map0","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]},"visibility":"public"},{"name":"map1","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]},"visibility":"public"},{"name":"prev_pos_hash","type":{"kind":"field"},"visibility":"public"},{"name":"prev_pos","type":{"kind":"field"},"visibility":"private"},{"name":"move","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"22":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"47":{"source":"global COLS = 18;\nglobal ROWS = 14;\n\nfn sq(x: Field) -> Field {\n    x * x\n}\n\nfn cu(x: Field) -> Field {\n    x * x * x\n}\n\n// hashes two inputs\nfn hash(val: Field, salt: Field) -> Field {\n    // let mut slt = salt as u64;\n    // let val = val as u64;\n    let salts = [\n        0xf8bf3bd6c22ba3b1bf3ab2e3fb40818cd4217ffbaf294ca42331d4e3043a0a6,\n        0x388c9fcf30fc2841d648f46bad01dd10bee9dc184d25eabc9f617021109cec3,\n        0x2bb7f397c5941ac67befa8b232f15c8853dac263da793555441a90cec83b6454,\n        0x17f389b52f9ea7a98874a4a31ef6a7beb43fb17db0e499250bb3f0181c59fb21,\n        0x3a2090eacb897a31fb10561d560a9aeec24b7ad14d17b145f20c875a0b28c7c,\n        0xc398534f0eb580f1fe4bf64553389e67cca4714399430e09619dcbee17ba099,\n        0x7095ac9fda46afa7f181259e3635feffa7f11ee63f3ee777a5cebf4822328c4,\n        0x2046f7cf1c8f13ef2b69cbc8bc0d5d809f82568abe2b33d1cd060958b1ced683,\n    ];\n\n    let v = val * salts[0];\n    let v = v * v * v * (salt + salts[1]); // v ** 3\n    let v = sq(sq(v)) * v * (salt + salts[2]); // v ** 5\n    let v2 = sq(v);\n    let v = cu(v2) * v * (salt + salts[3]); // v ** 7\n    let v2 = sq(v);\n    let v4 = sq(v2);\n    let v = sq(v4) * v2 * v * (salt + salts[5]); // v ** 11\n    let v4 = sq(sq(v));\n    let v = cu(v4) * v * (salt + salts[6]); // v ** 13\n    let v = sq(sq(sq(sq(v)))) * v * (salt + salts[7]); // v ** 17\n    let v2 = sq(v);\n    let v = sq(sq(sq(v2))) * v2 * v * (salt + salts[7]); // v ** 19\n\n    v\n}\n\nfn expand_position(position: Field) -> (u8, u8) {\n    let pos_bytes = position.to_be_bytes(2);\n    let mut px = pos_bytes[0];\n    let mut py = pos_bytes[1];\n    (px, py)\n}\n\nfn compress_position(x: u8, y: u8) -> Field {\n    (x as u64 + y as u64 * 256 as u64) as Field\n}\n\nfn make_move(prev_pos: Field, move: u8) -> (u8, u8) {\n    let (mut px, mut py) = expand_position(prev_pos);\n\n    if move == 1 {\n        py += 1;\n    } else if move == 2 {\n        py -= 1;\n    } else if move == 3 {\n        px -= 1;\n    } else if move == 4 {\n        px += 1;\n    } else {\n        assert(false, \"Invalid move\");\n    }\n    (py, px)\n}\n\n// Get map bit at x, y\nfn map_bit(map0: U128, map1: U128, x: u8, mut y: u8) -> u8 {\n    let mut map = map0;\n    let mut bit: u8 = y * COLS + x;\n    // print(x);\n    // print(\" \");\n    // print(y);\n    // print(\" \");\n    // print(bit);\n    // print(\" \");\n\n    // print(\"bit[ \");\n    // print(bit);\n\n    // We have a map in two U128, m0 and m1\n    // determine which one to use base on the row (y)\n    if bit > 125 {\n        bit = bit - 126;\n        map = map1;\n    }\n    // Now use map.lo or map.hi if bit value to fetch is greater than 63\n    let mut map_part = map.lo as u64;\n    let mut total_bits: u8 = 63;\n    // print(\" ~ \");\n    // print(bit);\n    // print(\" \");\n    if bit > 63 {\n        map_part = map.hi as u64;\n        bit -= 64;\n        total_bits = 61;\n    }\n\n    // bits to drop, everything after the reqd bit\n    let mut drop_bits = bit;\n    // print(\" ] \");\n    let divide_drop_bits: u64 = 1 as u64 << (drop_bits);\n    // divide by power of two to drop lower bits\n    let remainder_map = map_part / divide_drop_bits as u64;\n    // drop higher bits\n    let bit = remainder_map % 2;\n\n    // print(\"map: \");\n    // print(map_part);\n    // print(\" bit: \");\n    // print(bit);\n\n    bit as u8\n}\n\n// Main game circuit\n// map: public for Cairo contract to assert equivalence\n//      and that bushes are correct places in Cairo and the circuit\n// prev_pos_hash: public for Cairo contract to compare against the prev pos\n// prev_pos: private previous position (before playing move)\n// move: between 1, 2, 3, 4 for moving UP, DOWN, LEFT, RIGHT\n// salt: for hashing\n// returns: public new position hash output for Cairo contract to store in state for next iteration\nfn main(\n    map0: pub U128,\n    map1: pub U128,\n    prev_pos_hash: pub Field,\n    prev_pos: Field,\n    move: u8,\n    salt: Field //\n) -> pub Field {\n    // public for Cairo contract assert equivalence\n    // To make sure bushes are same in Cairo and the circuit\n\n    // Step 1: Output prev public hash\n    assert(hash(prev_pos, salt) == prev_pos_hash);\n\n    // Step 2: Process move\n    let (x, y) = make_move(prev_pos, move);\n\n    // Step 3: Assert move is in the bush\n    let bush = map_bit(map0, map1, x, y);\n    assert(1 == bush);\n\n    // Step 4: Output new public hash\n    let pos = compress_position(x, y);\n\n    hash(pos, salt)\n}\n\nmod test {\n    use crate::{main, map_bit, hash};\n    /*\n     000110011100110000\n     001110011100111000\n     001110000000011110\n     001100111111001111\n     011101111111100111\n     111001110011100000\n     110001100001100000\n    */\n    global MAP1 = U128::from_integer(8572555389858747807877673192308021344);\n\n    /*\n     000001100001100011\n     000001110011100111\n     111001111111101110\n     111100111111001100\n     011110000000011100\n     000111001110011100\n     000011001110011000\n    */\n    global MAP0 = U128::from_integer(2025978491129711385918832679433810840);\n\n    #[test]\n    fn test_bush() {\n        let rows = [\n            [0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0],\n            [0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0],\n            [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0],\n            [0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1],\n            [0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1],\n            [1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0],\n            [1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1],\n            [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1],\n            [1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0],\n            [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0],\n            [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0],\n            [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n            [0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0]\n        ];\n\n        for y in 0..14 {\n            // println(\"\");\n            // print(\"printing row: \");\n            // println(y);\n            let row = rows[y];\n            for i in 0..18 {\n                // let i = 17 - i;\n                // print(i);\n                // print(\" : \");\n                let bit = map_bit(MAP0, MAP1, i, y);\n                // print(bit);\n                if bit == row[i] {\n                    // print(\" == \");\n                } else {\n                    // print(\" != \");\n                }\n                // println(row[i]);\n                // assert(row[17 - i] == bit);\n            }\n        }\n    }\n\n    #[test]\n    fn test_main() {\n        let salt = 2134924215;\n\n        let prev_pos = 0x705;\n        let prev_pos_hash = hash(prev_pos, salt);\n        // print(\"post_hash: \");\n        // println(hash(0x704, salt));\n        let move = 2;\n        let result = main(MAP1, MAP0, prev_pos_hash, prev_pos, move, salt);\n        assert(result == hash(0x704, salt));\n    }\n}\n","path":"/Users/shramee/www/starknet/zk-chase/zk-circuits/noir/src/main.nr"}},"names":["main"]}